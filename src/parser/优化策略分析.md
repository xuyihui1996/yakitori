# 菜单 OCR 优化策略分析

## 📐 策略 1：先旋转再识别

### ✅ 优点

1. **阈值更合理**
   ```
   原始（横向）：1193 x 895 px
   旋转后（竖向）：895 x 1193 px
   
   列间距阈值：
   - 横向：1193 * 3% = 35.8px
   - 竖向：895 * 3% = 26.8px ✅ 更适合竖排列
   ```

2. **Vision API 识别更准确**
   - Vision 默认假设文字是"正向"的
   - 竖向图片 + 竖排文字 = 更自然的识别方向
   - `languageHints: ['ja']` 配合竖向布局效果更好

3. **bbox 坐标更直观**
   ```typescript
   // 竖向图片：
   // X 轴 = 列（左→右）
   // Y 轴 = 行（上→下）
   // 更符合竖排菜单的实际布局
   ```

4. **减少方向混淆**
   - 横向拍摄的竖排文字，Vision 可能识别为横排
   - 旋转后，Vision 明确知道这是竖排布局

### 🔧 实现方式

#### 方案 A：手动旋转（推荐）

```typescript
import sharp from 'sharp';

// 自动检测并旋转
if (width > height) {
  imageBuffer = await sharp(imageBuffer)
    .rotate(90)  // 或 -90，取决于拍摄方向
    .toBuffer();
}
```

**优点**：
- 完全控制旋转角度
- 可以根据 EXIF 信息自动判断
- 预处理后图片更标准化

#### 方案 B：使用 Vision API 的 orientation

```typescript
// Google Vision 会返回文字方向
const orientation = result.textAnnotations[0]?.orientation;
// 但这是事后信息，不如预处理
```

**缺点**：
- 需要先识别一次才知道方向
- 阈值计算仍然基于错误的宽高

### 🎯 推荐做法

**在 `parseMenuImageToItems` 之前预处理**：

```typescript
// scripts/parse-sample.ts
import { preprocessImageForVerticalMenu } from '../src/utils/imagePreprocess';

const imageBuffer = fs.readFileSync(imagePath);

// 预处理：自动旋转
const { buffer: processedBuffer, rotated } = 
  await preprocessImageForVerticalMenu(imageBuffer, {
    autoRotate: true,
    enhance: false,  // 可选：增强对比度
  });

const items = await parseMenuImageToItems(
  { type: 'buffer', data: processedBuffer },
  { languageHints: ['ja'] }
);
```

---

## ✂️ 策略 2：区域切分

### ✅ 优点

1. **减少干扰**
   ```
   完整菜单：100+ 个 items 混在一起
   切分后：每块 10-20 个 items
   ```

2. **提高精度**
   - 更少的 words 需要分组
   - 列分组更准确（列数从 16 → 2-3）
   - 价格列识别率提升

3. **并行处理**
   ```typescript
   // 可以并行识别多个区域
   const results = await Promise.all(
     regions.map(region => parseMenuImageToItems(region))
   );
   ```

4. **专注处理**
   - 每个区域可以用不同的策略
   - 例如：标题区域 vs 内容区域

### 🔧 实现方式

#### 方案 A：按坐标手动切分

```typescript
import sharp from 'sharp';

// 根据你的菜单布局定义切分区域
const regions = [
  { name: '串焼', x: 0, y: 0, width: 400, height: 600 },
  { name: '揚物', x: 400, y: 0, width: 400, height: 600 },
  { name: '飯物', x: 800, y: 0, width: 393, height: 600 },
];

for (const region of regions) {
  const regionBuffer = await sharp(imageBuffer)
    .extract({
      left: region.x,
      top: region.y,
      width: region.width,
      height: region.height,
    })
    .toBuffer();

  const items = await parseMenuImageToItems(
    { type: 'buffer', data: regionBuffer },
    { languageHints: ['ja'] }
  );

  // 保存结果时标记区域
  results.push({
    category: region.name,
    items,
  });
}
```

#### 方案 B：根据标题自动切分（高级）

```typescript
// 1. 先识别整张图片
// 2. 找到标题（"串焼"、"揚物"、"飯物"）
// 3. 根据标题的 bbox 自动切分
// 4. 再次识别每个区域
```

### ⚠️ 注意事项

1. **切分边界要准确**
   - 避免把一个菜品切成两半
   - 留一些 padding（10-20px）

2. **价格可能在边界**
   ```
   菜名：在左侧区域
   价格：可能在右侧区域
   → 需要跨区域匹配
   ```

3. **成本增加**
   ```
   完整图片：1 次 API 调用
   切分 3 块：3 次 API 调用
   成本 × 3
   ```

### 🎯 推荐做法

**混合策略**：

```typescript
// 1. 预处理：旋转
const rotatedBuffer = await autoRotateForVerticalText(imageBuffer);

// 2. 区域切分（可选）
const regions = detectMenuRegions(rotatedBuffer); // 自动检测或手动定义

// 3. 分别识别
const results = [];
for (const region of regions) {
  const items = await parseMenuImageToItems(region.buffer);
  results.push({ category: region.category, items });
}

// 4. 合并结果
return flattenResults(results);
```

---

## 📊 综合评估

### 策略组合建议

| 场景 | 旋转 | 切分 | 原因 |
|-----|------|------|------|
| **单张简单菜单** | ✅ 是 | ❌ 否 | 旋转足够，切分多余 |
| **多区域菜单** | ✅ 是 | ✅ 是 | 提高精度，值得成本 |
| **低质量照片** | ✅ 是 | ⚠️ 看情况 | 先增强质量，再决定是否切分 |
| **测试/调试** | ✅ 是 | ✅ 是 | 便于定位问题 |
| **生产环境** | ✅ 是 | ⚠️ 看成本 | 权衡精度 vs 成本 |

### 当前菜单的推荐方案

根据你的菜单图片（1193 x 895，横向拍摄）：

#### 🥇 最优方案：旋转 + 智能切分

```typescript
// 1. 旋转图片
const rotated = await autoRotateForVerticalText(imageBuffer);

// 2. 根据标题栏切分（你的菜单有明显的分区）
const regions = [
  { name: '串焼', x: 0, y: 0, width: 300, height: 900 },
  { name: '揚物', x: 300, y: 0, width: 300, height: 900 },
  { name: '飯物', x: 600, y: 0, width: 300, height: 900 },
  { name: '一品物', x: 900, y: 0, width: 293, height: 900 },
];

// 3. 并行识别
const results = await Promise.all(
  regions.map(async (region) => {
    const regionBuffer = await extractRegion(rotated, region);
    const items = await parseMenuImageToItems(regionBuffer);
    return { category: region.name, items };
  })
);
```

**预期效果**：
- ✅ 列分组更准确（每个区域 2-3 列而不是 16 列）
- ✅ 价格列识别率提升（从 0 个 → 每区域 1 个）
- ✅ 可以为每个分类添加 category 标签
- ✅ 并行处理，总耗时不增加太多

#### 🥈 次优方案：仅旋转

```typescript
// 简单但有效
const rotated = await autoRotateForVerticalText(imageBuffer);
const items = await parseMenuImageToItems(rotated);
```

**适用场景**：
- 快速测试
- 成本敏感
- 菜单结构简单

---

## 🎯 实施步骤

### Step 1：添加旋转功能

```bash
npm install sharp
```

```typescript
// scripts/parse-sample.ts 中添加
import { preprocessImageForVerticalMenu } from '../src/utils/imagePreprocess';

const { buffer, rotated } = await preprocessImageForVerticalMenu(imageBuffer);
console.log(`图片${rotated ? '已' : '未'}旋转`);
```

### Step 2：定义切分区域（可选）

```typescript
// src/utils/menuRegions.ts
export const MENU_REGIONS = {
  '居酒屋菜单': [
    { name: '串焼', x: 0, y: 0, width: 300, height: 900 },
    { name: '揚物', x: 300, y: 0, width: 300, height: 900 },
    // ...
  ],
};
```

### Step 3：测试对比

```bash
# 测试 A：原始图片
npm run parse:menu './截图.png'

# 测试 B：旋转后
npm run parse:menu './截图.png' --rotate

# 测试 C：旋转 + 切分
npm run parse:menu './截图.png' --rotate --split
```

---

## 💡 我的建议

### 对于你的项目：

1. **立即实施**：图片旋转
   - 成本：0（只是预处理）
   - 收益：阈值更准确，识别更好
   - 实现难度：低（已经写好 `imagePreprocess.ts`）

2. **后续考虑**：区域切分
   - 成本：API 调用 × 区域数
   - 收益：精度显著提升
   - 实现难度：中（需要定义切分逻辑）

3. **终极方案**：智能分区
   - 第一次识别：找标题栏位置
   - 根据标题自动切分
   - 第二次识别：每个区域
   - 成本：2x API 调用
   - 收益：全自动 + 高精度

---

## 🔍 性能预估

### 当前方案（无优化）
```
输入：1193 x 895 (横向)
识别：576 words → 190 items
列数：16 列 → 限制为 10 列
价格列：0 个
准确率：~10%
```

### 优化方案 A（仅旋转）
```
输入：895 x 1193 (竖向)
识别：~600 words → ~200 items
列数：预计 12 列
价格列：预计 6 个 ✅
准确率：预计 ~30-40%
```

### 优化方案 B（旋转 + 切分 4 块）
```
输入：每块 ~224 x 1193 (竖向)
识别：每块 ~150 words → ~50 items
列数：每块 2-3 列 ✅
价格列：每块 1 个 ✅
准确率：预计 ~60-80% ✅
成本：4x API 调用
```

---

## 🎉 总结

你的两个建议都非常好！

### 🌟 推荐实施顺序：

1. ✅ **立即**：图片旋转（已实现代码）
2. ✅ **下一步**：测试旋转效果
3. ⭐ **然后**：实现区域切分
4. 🚀 **最后**：对比效果，选择最佳方案

我已经为你创建了：
- `src/utils/imagePreprocess.ts` - 图片预处理工具
- `src/parser/优化策略分析.md` - 详细分析文档

现在可以测试旋转效果了！🎯


